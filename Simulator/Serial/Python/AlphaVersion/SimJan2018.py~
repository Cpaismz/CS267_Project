######################################################################################################################################
#
#				FireSimulator (Split) serial and parallel version 3.0b - October 2017 
#				Author: Cristobal Pais
#				example: mpiexec -n X python Path\Simulator1Beta.py  where X is the number of parallel processes
#
######################################################################################################################################
# Importations
import os
from random import uniform
from math import exp,pow
from itertools import repeat
from mpi4py import MPI
import time
import ctypes
from argparse import ArgumentParser
#from subprocess import call
#import pandas as pd

#Class importations
import WeatherFBP
import CellsFBP
import Forest 
import Lightning
#import Heuristic
#import Parallel
import Plot
import ReadData
import ReadDataPrometheus
import SpottingFBP
import Output_Grid

#Excel Importations
from openpyxl import *

# Input and outputfile names from the working directory (where the python script is, otherwise, insert the Path inside the os.chdir function)
cwd = os.path.dirname(os.path.realpath(__file__))
os.chdir(cwd)

soname = "FBPfunc5NODEBUG.so"
try:
    lib = ctypes.cdll.LoadLibrary(soname)
except:
    raise RuntimeError("Could not load the library="+soname)

# Main class with all the simulation scheme
class Main:		
######################################################################################################################################
#	
#		Simulator: All the simulation scheme is developed here
#
######################################################################################################################################

###Step -1: FBP
	# FType coefficients and data from FBP library
	listlen = 18
	ListOfCoefs = listlen * CellsFBP.fuel_coeffs   
	coef_ptr = ListOfCoefs()
	lib.setup_const(coef_ptr)
	FTypes2 = {"m1":0, "m2":1,"m3":2,"m4":3,"c1":4,"c2":5,"c3":6,"c4":7,"c5":8,"c6":9,"c7":10,"d1":11,"s1":12,"s2":13,"s3":14,"o1a":15,"o1b":16,"d2":17}
	
	# Forest Data (read table using c functions in class ReadData)
	parser = ArgumentParser()
	parser.add_argument("--input-data-file",
                    help="The name of the csv file that contains the data",
                    dest="input_file_name",
                    type=str,
                    default=None)
					
	parser.add_argument("--input-forest",
                    help="The name of the csv file that contains the forest grid data",
                    dest="input_forest",
                    type=str,
                    default=None)				
					
	parser.add_argument("--input-fpblookup",
                    help="The name of the csv file that contains the forest grid data",
                    dest="input_fbplookup",
                    type=str,
                    default="C:/Users/Lenovo/Desktop/SIM/Dogrib/fbp_lookup_table.csv")							

	parser.add_argument("--input-instance-folder",
                    help="The path to the folder contains all the files for the simulation",
                    dest="input_folder",
                    type=str,
                    default=None)				
					
	parser.add_argument("--weather",
                    help="The name of the csv file that contains the weather (hourly) data",
                    dest="input_weather",
                    type=str,
                    default="random")
		
	parser.add_argument("--spotting",
                    help="Activates spotting occurrence",
                    dest="input_spotting",
                    default=False,
					action='store_true')				
					
	parser.add_argument("--plot",
                    help="Plots are created after the simulation",
                    dest="input_plottrue",
                    default=False,
					action='store_true')	
	
	parser.add_argument("--verbose",
                    help="Output all the simulation log",
                    dest="verbose_input",
                    default=False,
					action='store_true')

	parser.add_argument("--ignition-point",
                    help="The name of the csv file that contains the ignition data",
                    dest="input_ignitions",
                    type=str,
                    default="")		

	parser.add_argument("--ignitions",
					help="Activates the predefined ignition points when using the folder execution",
					dest="act_ignitions",
					default=False,
					action="store_true")	
	
	parser.add_argument("--nsims",
                    help="Total number of simulations (replications)",
                    dest="input_nsims",
                    type=int,
                    default=1)	
					
	parser.add_argument("--PeriodLen",
                    help="Period length (needed for ROS computations)",
                    dest="input_PeriodLen",
                    type=float,
                    default=1)					
	
	parser.add_argument("--heuristic",
                    help="Heuristic used (number)",
                    dest="input_heur",
                    type=int,
                    default=0)		
	
	parser.add_argument("--statistics",
                    help="Excel file with statistics is created at the end of the simulation",
                    dest="input_excel",
                    default=False,
					action="store_true")	
					
	parser.add_argument("--combine",
                    help="Combine fire evolution diagrams with the forest background",
                    dest="input_combine",
                    default=False,
					action="store_true")					
					
	parser.add_argument("--save-memory",
                    help="Activates memory monitoring version (useful for very large instances)",
                    dest="input_save",
                    default=False,
					action="store_true")				

	parser.add_argument("--scenarios-out",
                    help="Activates scenario output files",
                    dest="input_scenario",
                    default=False,
					action="store_true")		
	
	parser.add_argument("--weather-file",
                    help="Activates weather stream file",
                    dest="file_weather",
                    default=False,
					action="store_true")		
	
	parser.add_argument("--no-output",
                    help="Activates no-output mode ",
                    dest="no_output",
                    default=False,
					action="store_true")		
					
	parser.add_argument("--output-grid",
                    help="Activates forest grid's output mode ",
                    dest="output_grid",
                    default=False,
					action="store_true")		
					
	parser.add_argument("--custom-thresholds",
                    help="Reads custom thresholds file ",
                    dest="read_threshold",
                    default=False,
					action="store_true")						
	
	args = parser.parse_args()
	filename = args.input_file_name
	Folder = args.input_folder
	SaveMem = args.input_save
	scenarios = args.input_scenario
	fileweather = args.file_weather
	nooutput = args.no_output
	Outputgrid = args.output_grid
	ReadThresholds = args.read_threshold
	
	if Folder != None:
		filename = os.path.join(Folder, "Data.dat")

	DF = ReadData.inputData(filename)
	#print DF	
		
	#Getting FType for each cell from data 
	FTypeCells2 = []
	for i in DF['fueltype']:
		FTypeCells2.append(i)
		
	###Step 0: Initializing Instances, classes, global parameters, sets, etc.
	#Global Parameters
	size = 1 
	rank = 0
	verbose = args.verbose_input
	plottrue = args.input_plottrue
	Global_period = 1
	Max_Fire_Periods = 2016
	Max_Periods = 12
	TotalYears= 4
	TotalSims = args.input_nsims
	Year = 1
	Sim = 1
	Fire_Period = [0 for i in range(TotalYears)]
	NoIgnition=None
	MessagesSent=None
	plotnumber = 1
	
	###################################################
	''' Modification October 2017
	    Period length: in seconds for the moment
	'''
	PeriodLen = args.input_PeriodLen
	print "-----------------------------------------------------------------------------------"
	print "Period Length for ROS computations [s]: ", PeriodLen
	print "-----------------------------------------------------------------------------------"
	'''
		Period length: in seconds for the moment
	'''
	###################################################
	
	#	Simulations loop
	while Sim <= TotalSims:
		###Step 0: Initializing Instances, classes, global parameters, sets, etc.
		#Global Parameters
		size = 1 
		rank = 0
		verbose = args.verbose_input
		if nooutput == True:
			verbose = False
		plottrue = args.input_plottrue
		Global_period = 1
		Max_Fire_Periods = 2016
		Max_Periods = 12
		TotalYears= 4
		TotalSims = args.input_nsims
		Year = 1
		Fire_Period = [0 for i in range(TotalYears)]
		NoIgnition=None
		MessagesSent=None
		plotnumber = 1
		
		if rank == 0:
			print "------------------------------------------------- Simulation Number ",Sim,"-------------------------------------------------" 
				
		FI = [0]*Max_Fire_Periods
		HPeriod = [0]
		BurntP = [[] for i in repeat(None, Max_Fire_Periods)]
		
		Initial_Time = time.clock()
		if verbose ==  True:
			print "Initial Time:",Initial_Time
			
		#Read Forest
		if rank == 0 and nooutput == False:
			print "\n----------------- Forest Data -----------------"
		
		ForestFile = args.input_forest
		FBPlookup = args.input_fbplookup
		Ignitions = args.input_ignitions
		Thresholds = {}
		
		if Folder != None:
			ForestFile = os.path.join(Folder, "Forest.asc")
			FBPlookup = os.path.join(Folder, "fbp_lookup_table.csv")
			Ign = args.act_ignitions
			if Ign == True:
				Ignitions = os.path.join(Folder, "IgnitionPoints.csv")	
			if ReadThresholds == True:
				if nooutput == False:
					print "WARNING: Reading Custom Thresholds will be deprecated."
				ThresholdFile = os.path.join(Folder, "Thresholds.csv")
				Thresholds = ReadDataPrometheus.ReadThresholds(ThresholdFile,nooutput)
				
		FBPDict,ColorsDict =  ReadDataPrometheus.Dictionary(FBPlookup)
		CellsGrid3,CellsGrid4,Rows,Cols,AdjCells,CoordCells = ReadDataPrometheus.ForestGrid(ForestFile,FBPDict)
			
		if Ignitions != "":
			Ignitions = ReadDataPrometheus.IgnitionPoints(Ignitions)
			if rank == 0 and nooutput == False:
				print "We have specific ignition points"
				print "Ignitions:",Ignitions
			
		if Ignitions == "" and rank == 0 and nooutput == False:
			print "No ignition points"
			
		if rank == 0 and nooutput == False:	
			print "Rows:",Rows,"Cols:",Cols, "NCells:",Rows*Cols
			
		FTypeCells = []
		StatusCells = []
		Colors = []
		RealCells = []
		cellcounter=1
			
		for i in range(0,len(CellsGrid4)):
			if str.lower(CellsGrid4[i]) not in FTypes2.keys():
				FTypeCells.append(0)
				StatusCells.append(4)
				CellsGrid4[i] = "s1"
				RealCells.append(0)
			else:
				FTypeCells.append(2)
				StatusCells.append(0)
				RealCells.append(cellcounter)
				cellcounter+=1
		
			if str(CellsGrid3[i]) not in ColorsDict.keys():
				Colors.append((1.0,1.0,1.0,1.0))
				
			if 	str(CellsGrid3[i]) in ColorsDict.keys():
				Colors.append(ColorsDict[str(CellsGrid3[i])])
		
		#Releasing memory
		del CellsGrid3
		del ColorsDict
			
		if rank == 0 and nooutput == False:		
			print "------------ End read forest data -------------"
		
			#Main parameters (Forest)
		NCells = Rows*Cols
		IDF = 1
		Location = "My_Mind"
		Coord = [1,1,100]
		Area = 24000.0
		Vol = 340000.0
		Age = 12.0
		Perimeter = 540000.0
		FTypes = {0: "NonBurnable", 1: "Normal", 2: "Burnable"}
		
		#Cells list
		Cells_Obj = {}
				
		# Reading instance data (explicit for the moment, final version may read it from a source file)
		AreaCells = 100 
		VolCells = 100
		AgeCells = 1 
		TerrainCells = 0 
		PerimeterCells = 0 
		
		#Weather Instance (initial weather)
		WeatherOpt = str.lower(args.input_weather)
		InitialWeather = {"Wind_Speed": 30, "Wind_Direction": 25, "Temperature": 23, "DPoint": 8.4, "Rain": 0, "Radiation": 0, "RHumidity":0}
		Weather_Obj = WeatherFBP.Weather(InitialWeather)
		
		if fileweather == True:
			weatherperiod = 0
			if nooutput==False:
				print "Reading weather file"
			WeatherOpt = "random"
			WindSpeed,WindDirection,Temperature,RHumidity,Precipitation = Weather_Obj.Read_WeatherFBP(Folder)
			DF = Weather_Obj.update_Weather_FBPReadFile(weatherperiod,DF,WindSpeed,WindDirection,Temperature,RHumidity,Precipitation,verbose)
			
			WeatherSet = {"Wind_Speed": WindSpeed[weatherperiod], "Wind_Direction": WindDirection[weatherperiod], 
									"Temperature": Temperature[weatherperiod], "DPoint": 8.4, 
									"Rain": Precipitation[weatherperiod], "Radiation": 0, 
									"RHumidity":RHumidity[weatherperiod]}
			
			Weather_Obj.set_Weather(WeatherSet)
			
			if verbose == True:
				Weather_Obj.print_info(0, "Week")
			
			if verbose == True:
				print "DF", DF[["ws","waz","saz"]]	
				print "WindDirection", WindDirection[0]
					
		#Initializing Forest Instance
		Forest1 = Forest.Forest(IDF,Location,Coord,NCells,Area,Vol,Age,Perimeter,FTypes)
		if verbose == True and rank==0:
			print "\n" + "------------------------ Forests lists ------------------------"
			Forest1.print_info()
		
		# Serial approach: Initializing cells objects
		if size == 1:
			if verbose == True:
				print "\n","Serial Initialization","\n","Number of workers: 1"
				print "---------------------- End initialization ------------------------------"	
		
		
		#Initializing List of Cells and weather (printing info, if verbose)
		if verbose == True and rank == 0:
			#Printing cells
			#print "\n" + "------------------------- Cells lists -------------------------"
			#for i in range(0,NCells):
				#Cells_Obj[i].print_info()
				#print "\n"
			#Printing weather
			#Weather_Obj.print_info(weatherperiod,"Week")		
			Weather_Obj.print_info_new(weatherperiod,"Week", WindSpeed,WindDirection,Temperature,RHumidity,Precipitation)		
		
		#Initializing plot object and plot the initial forest
		if plottrue == True:
			PlotPath = os.path.join(Folder, "Plots")
			if not os.path.exists(PlotPath):
				os.makedirs(PlotPath)
			Plotter = Plot.Plot()
			emptylist = [[] for i in range(0,NCells)]
			if rank == 0:
				if os.path.isfile(os.path.join(Folder, "ForestInitial.png")) == True:
					if nooutput == False:
						print "Forest already exists"
				else:	
					Plotter.PlotForestOnly(Colors,CoordCells,plotnumber,0,Year,False,Rows,Cols,Folder)
						
		#Initializing Lambda Instance
		Lambda_Strike = Lightning.Lightning()
			
		#Sets (Available cells, burning cells, burnt cells and harvest cells)
		avail=[]
		nonbur=[]
		
		for i in range(0,NCells):
			if StatusCells[i] != 4:
				avail.append(i+1)
			if StatusCells[i] == 4:
				nonbur.append(i+1)
				
		AvailCells_Set = set(avail)
		del avail
		NonBurnableCells_Set = set(nonbur)
		del nonbur
		BurningCells_Set = set()
		BurntCells_Set = set()
		HarvestCells_Set = set()
		
		#Printing info about the cells' status
		if rank == 0 and verbose == True:
			print "\n" +"Set information period (week"+str(Global_period)+")"
			print "Available Cells: " + str(AvailCells_Set)
			print "Non Burnable Cells:" +str(NonBurnableCells_Set)
			print "Burning Cells: " + str(BurningCells_Set)
			print "Burnt Cells: " + str(BurntCells_Set)
			print "Harvest Cells: " + str(HarvestCells_Set)
		
		
		# Spotting information
		spotting = args.input_spotting
		'''
		if spotting == True:
			Angles, Distances = SpottingFBP.AnglesDistSpot_03Aug_Ind(CoordCells,0)	
			print "Angles:",Angles
			print "\nDistances:",Distances
		else:
			Angles = None
			Distances = None
		'''

		
		#Years' loop starts	
	###Years' loop (start)
		while Year <= TotalYears:
			### Step 1: Lightning/Ignition loop in order to find the first week with fire
			#Loop for finding next fire week
			if rank == 0:
				#Printing information if verbose is true
				if verbose == True:
					print "\n","------------------------------------ Current Year: ",Year, "------------------------------------"
					print "---------------------- Step 1: Ignition ----------------------"
				
				if SaveMem == True:
					for c in BurntCells_Set:
						if (c-1) in Cells_Obj.keys():
							if verbose == True:
								print "Deleting burnt cells from list---------------------------------------------"
								print "Deleted:",c
							del Cells_Obj[c-1]
						
				#Parameters and variables
				aux=0
				loops=0
				NoIgnition = False
				
				# Starting fire week 
				if Ignitions == "":
					while Global_period<=Max_Periods:
						#If a lightning occurs in a week, we select that week
						if Lambda_Strike.Lambda_NH(Global_period,verbose) == True:
							Sel_Week = Global_period
							if verbose == True:
								print "Selected Week: " + str(Sel_Week)
							break
						else: 
							Global_period+=1
							weatherperiod += 1
					
				else: 
					Global_period=1 
					weatherperiod=0
					Sel_Week = 1
				
				#Go to that period/week
				Global_period = Sel_Week
				Fire_Period[Year-1] = (Global_period-1)*7*24+1
				
				if verbose == True:
					print ""
					print "Actual Period (Week): "+str(Global_period)	
					print "Actual Fire Period (Hour): "+str(Fire_Period[Year-1])
							
				# Select the "burning" cell
				aux=0
				loops=0
				NoIgnition = False
							
				# Select the "burning" cell
				if Ignitions == "":
					while True:
						aux = int(uniform(0,1)*NCells)	
						#print "aux:",aux
						if StatusCells[aux] != 4 and (aux+1) not in BurntCells_Set:
							if aux not in Cells_Obj.keys():
								Cells_Obj[aux] = CellsFBP.Cells((aux+1),AreaCells,CoordCells[aux],AgeCells,FTypeCells[aux],coef_ptr[FTypes2[str.lower(CellsGrid4[aux])]],TerrainCells,VolCells,PerimeterCells,StatusCells[aux],AdjCells[aux],Colors[aux],RealCells[aux])
								'''
								
								'''
								# Avail set modification for initialization
								Cells_Obj[aux].InitializeFireFields(CoordCells, AvailCells_Set)
								
								'''
						
								'''
						
						
							#If the cell is available and burnable
							if Cells_Obj[aux].get_Status() == "Available" and Cells_Obj[aux].FType != 0:
								if Cells_Obj[aux].ignition(Fire_Period[Year-1],Weather_Obj.get_Weather(),Year,Ignitions) == True:
									#If we have an ignition, change the status of the forest
									FI[Fire_Period[Year-1]-1]=Cells_Obj[aux].ID
									BurntP[Fire_Period[Year-1]-1]=Cells_Obj[aux].ID
									for i in range(Fire_Period[Year-1],Max_Fire_Periods):
										BurntP[i] = Cells_Obj[aux].ID
									# Printing info about ignitions		
									if verbose == True:
										print "Cell "+str(Cells_Obj[aux].ID)+" Ignites"
										print "Cell "+str(Cells_Obj[aux].ID)+" Status: " + Cells_Obj[aux].get_Status()	
									if plottrue == True and SaveMem == True:
										Plotter.forest_plotV3_FreeMem(Cells_Obj,emptylist,plotnumber,Fire_Period[Year-1],Year,False,Rows,Cols,PlotPath,CoordCells,BurntCells_Set,Sim)
										plotnumber+=1
									if plottrue == True and SaveMem != True:
										Plotter.forest_plotV3(Cells_Obj,emptylist,plotnumber,Fire_Period[Year-1],Year,False,Rows,Cols,PlotPath,Sim)
										plotnumber+=1	
										
									break
									
						#Updating parameters inside the loop
						loops+=1
						
						#Maximum number of iterations
						if loops>NCells:
							NoIgnition = True
							break
					
				if Ignitions != "":
					if Ignitions[Year] not in BurntCells_Set and StatusCells[Ignitions[Year]-1]!=4:
						if (Ignitions[Year]-1) not in Cells_Obj.keys():
							Cells_Obj[Ignitions[Year]-1] = CellsFBP.Cells((Ignitions[Year]),AreaCells,CoordCells[Ignitions[Year]-1],AgeCells,FTypeCells[Ignitions[Year]-1],coef_ptr[FTypes2[str.lower(CellsGrid4[Ignitions[Year]-1])]],TerrainCells,VolCells,PerimeterCells,StatusCells[Ignitions[Year]-1],AdjCells[Ignitions[Year]-1],Colors[Ignitions[Year]-1],RealCells[Ignitions[Year]-1])
							
							'''
							
							'''
							Cells_Obj[Ignitions[Year]-1].InitializeFireFields(CoordCells, AvailCells_Set)
							#Cells_Obj[Ignitions[Year]-1].InitializeFireFields(CoordCells)
						
							'''
							
							
							'''
						
						
						if Cells_Obj[Ignitions[Year]-1].get_Status() != "Available" or Cells_Obj[Ignitions[Year]-1].FType == 0:
							NoIgnition = True
						
						if Cells_Obj[Ignitions[Year]-1].get_Status() == "Available" and Cells_Obj[Ignitions[Year]-1].FType != 0:
							if Cells_Obj[Ignitions[Year]-1].ignition(Fire_Period[Year-1],Weather_Obj.get_Weather(),Year,Ignitions) == True:
																
								FI[Fire_Period[Year-1]-1]=Cells_Obj[Ignitions[Year]-1].ID
								BurntP[Fire_Period[Year-1]-1]=Cells_Obj[Ignitions[Year]-1].ID
								for i in range(Fire_Period[Year-1],Max_Fire_Periods):
									BurntP[i] = Cells_Obj[Ignitions[Year]-1].ID
										
								# Printing info about ignitions		
								if verbose == True:
									print "Cell "+str(Cells_Obj[Ignitions[Year]-1].ID)+" Ignites"
									print "Cell "+str(Cells_Obj[Ignitions[Year]-1].ID)+" Status: " + Cells_Obj[Ignitions[Year]-1].get_Status()	
								if plottrue == True and SaveMem == True:
									Plotter.forest_plotV3_FreeMem(Cells_Obj,emptylist,plotnumber,Fire_Period[Year-1],Year,False,Rows,Cols,PlotPath,CoordCells,BurntCells_Set,Sim)
									plotnumber+=1
								if plottrue == True and SaveMem != True:
									Plotter.forest_plotV3(Cells_Obj,emptylist,plotnumber,Fire_Period[Year-1],Year,False,Rows,Cols,PlotPath,Sim)
									plotnumber+=1	
						
					else:
						NoIgnition = True
						if nooutput == False:
							print "No ignition during year "+str(Year)+", cell "+str(Ignitions[Year])+ " is already burnt or non-burnable type"
							
				#If ignition occurs, we update the forest status
				if NoIgnition == False:
					#Updating AvailCells and BurntCells sets	
					if Ignitions == "":
						NewID = Cells_Obj[aux].ID
						Aux_set = set([NewID])
						BurningCells_Set = BurningCells_Set.union(Aux_set)
						AvailCells_Set = AvailCells_Set.difference(BurningCells_Set)
					
					else:
						NewID = Cells_Obj[Ignitions[Year]-1].ID
						Aux_set = set([Ignitions[Year]])
						BurningCells_Set = BurningCells_Set.union(Aux_set)
						AvailCells_Set = AvailCells_Set.difference(BurningCells_Set)
						
				#Printing information about the forest
				if verbose == True:
					print ""
					print "Available cells: " + str(AvailCells_Set)
					print "Non Burnable Cells:" +str(NonBurnableCells_Set)
					print "Burning cells: " + str(BurningCells_Set)
					print "Harvest cells: " + str(HarvestCells_Set)
					print "Burnt cells: " +str(BurntCells_Set)
								
				#Next Period: t=t+1. Update Weather
				Fire_Period[Year-1]+=1
				Weather_Obj.update_Weather(Global_period,WeatherOpt)
				if fileweather == True and weatherperiod < len(WindSpeed):
					weatherperiod +=1
					DF = Weather_Obj.update_Weather_FBPReadFile(weatherperiod,DF,WindSpeed,WindDirection,Temperature,RHumidity,Precipitation,verbose)
					'''
					set weather
					'''
					WeatherSet = {"Wind_Speed": WindSpeed[weatherperiod], "Wind_Direction": WindDirection[weatherperiod], 
									"Temperature": Temperature[weatherperiod], "DPoint": 8.4, 
									"Rain": Precipitation[weatherperiod], "Radiation": 0, 
									"RHumidity":RHumidity[weatherperiod]}
			
					Weather_Obj.set_Weather(WeatherSet)
					
					'''
					end set weather
					'''
				else:
					DF = Weather_Obj.update_Weather_FBP(Global_period,DF,WeatherOpt)
				
				
				if verbose == True:
					print "Actual Week: "+str(Global_period)
					print "Fire Period Starts: " + str(Fire_Period[Year-1])
					print ""
					if weatherperiod != True:
						Weather_Obj.print_info(Global_period,"Week")
					if weatherperiod == True:
						Weather_Obj.print_info(weatherperiod,"Week")
							
					# End of the ignition step
					print ""
					print "Next Fire Period: " + str(Fire_Period[Year-1])
											
				if Global_period == 12 or Fire_Period[Year-1] == 2016:
					print "-------------------------------------------------------------------------\n"+ "End of the fire year",Year,"-------------------------------------------------------------------------"	
					
			### End Step 1
		
			#If no ignition occurs, go to next year (no multiple ignitions per year, only one)
			if NoIgnition == True:
				if rank == 0 and verbose == True:
					print "No ignition in year",Year
				#Next year, reset the week
				Year+=1	
				Global_period=1
			
			#If an ignition happened, enter in fire dynamic loop
			if NoIgnition == False:
				
				### Steps 2 and 3: Send/Receive messages (fire dynamic)
				#Fire dynamic loop (fire periods)
				while Fire_Period[Year-1]<=Max_Fire_Periods:
					### Step 2: Sending messages
					# Initial Parameters
					MessagesSent=False
					SendMessageList = [[] for i in repeat(None, NCells)]
					
					#Printing info
					if rank == 0 and verbose == True:
						print "\n"+"---------------------- Step 2: Sending Messages from Ignition ----------------------"
						print "Actual Week: " + str(Global_period)
						print "Actual Fire Period: "+str(Fire_Period[Year-1])
						print "Burning Cells: "+str(BurningCells_Set)
						print "Burnt Cells: "+str(BurntCells_Set)
						
					'''
					Cleaning ROSAngleDir dictionaries based on the current burning cells
					'''
					
					if verbose == True: 
						print " -------------------- NEW CLEANING STEP ------------------------"
					# For all the cells already initialized
					for cell in Cells_Obj.keys():
						# Check those cells with at least one possible neighbor to send fire
						if len(Cells_Obj[cell].ROSAngleDir) > 0:
							
							# Delete adjacent cells that are not available 
							for angle in Cells_Obj[cell].angle_to_nb:
								nb = Cells_Obj[cell].angle_to_nb[angle]
								
								if nb not in AvailCells_Set and angle in Cells_Obj[cell].ROSAngleDir:
									
									if verbose == True: 
										print "Cell", cell+1, "has garbage inside ROSAngleDir"
						
									Cells_Obj[cell].ROSAngleDir.pop(angle)
					if verbose == True: 
						print "----------------------------------------------------------------------"
					
					
					
					
					
					
					'''
					'''
				
					#Determining the amount of processes to use (no more than the number of burning cells)
					if size>len(BurningCells_Set):
						size = len(BurningCells_Set)
						if rank ==0 and verbose == True:
							print "More processes than jobs, reducing world size to",size
					
					#If size equals to 0, we don't have works (never happens because of if no ignition)
					if size == 0:
						break
					
					#If size is bigger than 0 (we have at least one burning cell), if size == 1, serial version
					#Serial version of the code
					if size == 1 and rank == 0:
						if verbose ==True:
							print "\n","---Serial version of the code---"
							
						# RepeatFire
						RepeatFire = False	
						
						for cell in BurningCells_Set:
							#Aux_List = Cells_Obj[cell-1].send_msg_FBP(Fire_Period[Year-1],Weather_Obj.get_Weather(),AvailCells_Set,verbose,DF,coef_ptr,WeatherOpt,spotting,Cells_Obj,Thresholds,CoordCells)
							
							########################################################
							''' New burning logic  (EXTRA INPUT PeriodLen)
							
							'''
							
							if verbose == True:
								print("Cell object new fields")
								print("ID:",Cells_Obj[cell-1].ID)
								print("FireProgress:",Cells_Obj[cell-1].FireProgress)
								print("AngleDict:",Cells_Obj[cell-1].AngleDict)
								print("ROSAngleDir:",Cells_Obj[cell-1].ROSAngleDir)
								print("DistToCenter:",Cells_Obj[cell-1].DistToCenter)
								print("angle_to_nb:",Cells_Obj[cell-1].angle_to_nb)
						
							# Check if the burning cell can send more messages or not 
							if len(Cells_Obj[cell-1].ROSAngleDir) > 0:
								if verbose == True:
									print "Cell", cell, "can still send messages to neighbors"
								Aux_List = Cells_Obj[cell-1].manageFire(Fire_Period[Year-1],Weather_Obj.get_Weather(),AvailCells_Set,verbose,DF,coef_ptr,WeatherOpt,spotting,Cells_Obj,Thresholds,CoordCells,PeriodLen)
							
							else:
								if verbose == True:
									print "Cell", cell, "does not have any neighbor available for receiving messages"
								Aux_List = []
							'''	
							'''
							########################################################
							
							# Debug
							if verbose == True:
								print "Aux list!!!!:", Aux_List
							
							# Original condition
							#if len(Aux_List) > 0:
							if len(Aux_List) > 0 and Aux_List[0] != "True" :
								if verbose == True:
									print "List is not empty"
								MessagesSent=True
								SendMessageList[Cells_Obj[cell-1].ID-1] = Aux_List
								if verbose == True:
									print "SendMessageList: ", SendMessageList
								
														
							'''
							Major modifications.........
							'''
							if len(Aux_List) > 0 and Aux_List[0] == "True":
								if verbose == True:
									print "Fire is still alive and we may repeat if no other messages......"
									RepeatFire = True
									
								
								
								
							
	##############################################################						
								
							if len(Aux_List) == 0:
								if verbose == True:
									print "List is empty"
					
					# Check the conditions for repeating, stopping, etc.... 
					# Main change......
					Global_Message_Aux = [val for sublist in SendMessageList for val in sublist]
					if verbose == True:
						print "Global_Message_Aux:", Global_Message_Aux
						print "RepeatFire:", RepeatFire
						
					# if we have at least one cell that neeeds repetition and no other messages exists....
					# We repeat!!!!
					if RepeatFire == True and len(Global_Message_Aux) == 0:
						# Update fire period 
						print ""
						print "Fires are still alive and no message has been generated during this period"
						print "Current Fire period: ",Fire_Period[Year-1]
						Fire_Period[Year-1] += 1 
						print "New Fire period: ", Fire_Period[Year-1]
						print ""
					
					if RepeatFire == True and len(Global_Message_Aux) > 0:
						print "Messages have been sent, next step"
						RepeatFire = False 
							
					# Checking if the list is empty and no repeat flag, then if it is empty, end of the actual fire dynamic period, next year
					if MessagesSent==False and RepeatFire==False:
						if rank == 0 and verbose == True:
							print "\n","No messages during the fire period, end of year",Year
						#Next year, reset weeks and update burnt cells from burning cells
						Year+=1
						Global_period=1
						BurntCells_Set = BurntCells_Set.union(BurningCells_Set)
						BurningCells_Set = set()
						
						if SaveMem != True:
							for br in BurntCells_Set:
								Cells_Obj[br-1].Status=2
					
						if SaveMem == True:
							for c in BurntCells_Set:
								if (c-1) in Cells_Obj.keys():
									if verbose == True:
										print "Deleting burnt cells from list---------------------------------------------"
										print "Deleted:",c
									del Cells_Obj[c-1]
					
						break
														
					#Otherwise, go to next fire period and receiving messages loop
					if MessagesSent==True and RepeatFire==False:
						#Global list with messages (all messages)
						Global_Message_List = [val for sublist in SendMessageList for val in sublist]
						Global_Message_List.sort()
											
						if rank == 0 and verbose == True:
							print "Lists of messages per Cell: "+ str(SendMessageList)
							print "Global Message Lists: " + str(Global_Message_List)
							print "We have at least one message: "+str(MessagesSent)
						
					
						if rank == 0:
							for bc in Global_Message_List:
								if (bc-1) not in Cells_Obj.keys() and bc not in BurntCells_Set:
									Cells_Obj[bc-1] = CellsFBP.Cells((bc),AreaCells,CoordCells[bc-1],AgeCells,FTypeCells[bc-1],coef_ptr[FTypes2[str.lower(CellsGrid4[bc-1])]],TerrainCells,VolCells,PerimeterCells,StatusCells[bc-1],AdjCells[bc-1],Colors[bc-1],RealCells[bc-1])
									
									'''
									New cell initialization
									'''
									Cells_Obj[bc-1].InitializeFireFields(CoordCells, AvailCells_Set)
									#Cells_Obj[bc-1].InitializeFireFields(CoordCells)
									'''
									
									'''
								
								
								
								
							if plottrue == True and SaveMem == True:
								Plotter.forest_plotV3_FreeMem(Cells_Obj,SendMessageList,plotnumber,Fire_Period[Year-1],Year,False,Rows,Cols,PlotPath,CoordCells,BurntCells_Set,Sim)
								plotnumber+=1
								
							if plottrue == True and SaveMem != True:
								Plotter.forest_plotV3(Cells_Obj,SendMessageList,plotnumber,Fire_Period[Year-1],Year,False,Rows,Cols,PlotPath,Sim)
								plotnumber+=1
								
						for c in Cells_Obj.keys():
							Cells_Obj[c].got_burnt_from_mem(Fire_Period[Year-1],SendMessageList,Year-1,verbose)
												
					### End Step 2
						# Releasing Memory 
						del SendMessageList
											
						###Step 3: Receiving messages
						#Printing information
						if rank == 0 and verbose == True:
							print "\n"+"---------------------- Step 3: Receiving and processing messages from Ignition ----------------------"
							print "Size of the world: ",size
						# Initializing Parameters
						BurntList = []
						NMessages = [0]*NCells
						GotMsg_Set = set(Global_Message_List)
						
						# Check which cells got messages and how many of them
						if rank == 0 and verbose == True:
							print "Cells receiving messages: "+str(GotMsg_Set)
												
						for i in range(1,NCells+1):
							NMessages[i-1]=Global_Message_List.count(i)
							if rank == 0 and verbose == True and NMessages[i-1] != 0:
								print "Cell "+str(i)+ " receives "+str(NMessages[i-1]) + " messages" 
						
						# Releasing Memory 
						del Global_Message_List
											
						#Determining the amount of processes to use (no more than the number of cells)
						if size>len(GotMsg_Set):
							size = len(GotMsg_Set)
							if rank ==0 and verbose == True:
								print "More processes than jobs, reducing world size to",size
					
						#If size equals to 0, we don't have works (happens because of no messages)
						if size == 0:
							break
					
						#If size is bigger than 0 (we have at least one burning cell), if size == 1, serial version
						#Serial version of the code
						if size == 1 and rank == 0:
							if verbose ==True:
								print "\n","---Serial version of the code---"
							# Check if they got burnt (probabilities)
							if verbose == True:
								print "\n" + "Cells status"
							for bc in GotMsg_Set:
								if bc not in BurntCells_Set:
									if (bc-1) not in Cells_Obj.keys():
										Cells_Obj[bc-1] = CellsFBP.Cells((bc),AreaCells,CoordCells[bc-1],AgeCells,FTypeCells[bc-1],coef_ptr[FTypes2[str.lower(CellsGrid4[bc-1])]],TerrainCells,VolCells,PerimeterCells,StatusCells[bc-1],AdjCells[bc-1],Colors[bc-1],RealCells[bc-1])
										
										'''
										New cell initialization
										'''
										print "-------- Initializing new cell ", bc, "--------"
										#Cells_Obj[bc-1].InitializeFireFields(CoordCells)
										Cells_Obj[bc-1].InitializeFireFields(CoordCells, AvailCells_Set)
										print "-----------------------------------------------"
										'''
										'''
										
										
										
								
									if Cells_Obj[bc-1].FType != 0:
										#Check_Burnt = Cells_Obj[bc-1].got_burnt_FBP(Fire_Period[Year-1],Weather_Obj.get_Weather(),NMessages[bc-1],Year,verbose,DF,coef_ptr,Thresholds)
								
										'''
										New get_burned method
										'''
										
										Check_Burnt = Cells_Obj[bc-1].get_burned(Fire_Period[Year-1],Weather_Obj.get_Weather(),NMessages[bc-1],Year,verbose,DF,coef_ptr,Thresholds)
										
										'''
										End of new method
										'''
										
								
								
								



									if Cells_Obj[bc-1].FType == 0:
										Check_Burnt  = False
									if verbose == True:
										print "Cell "+ str(Cells_Obj[bc-1].ID) +" got burnt: " + str(Check_Burnt)
									if Check_Burnt == True:
										BurntList.append(Cells_Obj[bc-1].ID)
							
							if verbose == True:
								print "\n"+"Results"
								print "Burnt List: " +str(BurntList)
						
									
						# Update cells status (burnt or not burnt), Update AvailCells and BurntCells sets
						Aux_set = set(BurntList)
						BurningCells_Set = BurningCells_Set.union(Aux_set)
						
						# Releasing Memory 
						del Aux_set
											
						AvailCells_Set = AvailCells_Set.difference(BurningCells_Set)
						if rank == 0 and verbose == True:
							print "Available cells: " + str(AvailCells_Set)
							print "Non Burnable Cells:" +str(NonBurnableCells_Set)
							print "Burning cells: " + str(BurningCells_Set)
							print "Harvest cells: " + str(HarvestCells_Set)
							print "Burnt cells: " + str(BurntCells_Set)
							
						for t in range(Fire_Period[Year-1],Max_Fire_Periods+1):
							BurntP[t-1]=list(BurningCells_Set)
						
						#Plot
						if rank == 0 and plottrue == True:
							if SaveMem == True:
								Plotter.forest_plotV3_FreeMem(Cells_Obj,emptylist,plotnumber,Fire_Period[Year-1],Year,False,Rows,Cols,PlotPath,CoordCells,BurntCells_Set,Sim)
								plotnumber+=1
							if SaveMem != True:
								Plotter.forest_plotV3(Cells_Obj,emptylist,plotnumber,Fire_Period[Year-1],Year,False,Rows,Cols,PlotPath,Sim)
								plotnumber+=1
						
						# Next Period: t=t+1. Update Weather
						Fire_Period[Year-1]+=1
						Weather_Obj.update_Weather(Fire_Period[Year-1],WeatherOpt)
						if fileweather == True and weatherperiod < len(WindSpeed):
							weatherperiod += 1
							DF = Weather_Obj.update_Weather_FBPReadFile(weatherperiod,DF,WindSpeed,WindDirection,Temperature,RHumidity,Precipitation,verbose)
							'''
							set weather
							'''
							WeatherSet = {"Wind_Speed": WindSpeed[weatherperiod], "Wind_Direction": WindDirection[weatherperiod], 
											"Temperature": Temperature[weatherperiod], "DPoint": 8.4, 
											"Rain": Precipitation[weatherperiod], "Radiation": 0, 
											"RHumidity":RHumidity[weatherperiod]}
					
							Weather_Obj.set_Weather(WeatherSet)
					
							'''
							end set weather
							'''
						
						else:
							DF = Weather_Obj.update_Weather_FBP(weatherperiod,DF,WeatherOpt)
						
						if rank == 0 and verbose == True:
							print ""
							if weatherperiod != True:
								Weather_Obj.print_info(Fire_Period[Year-1],"hour")
							if weatherperiod == True:
								Weather_Obj.print_info(weatherperiod,"hour")
							
							print ""
							print "Actual Period (week): "+str(Global_period)
							print "Actual Fire Period: "+str(Fire_Period[Year-1])
							
						#Equivalence between fire periods and weeks (hours for the moment)
						if Fire_Period[Year-1] == 168:
							Global_period+=1
						
						### End Step 3
						
				### End of fire dynamic
	###Year's loop (end)	


	### Step 4: Results
		#End of the code, output files with statistics and plots
		for br in BurntCells_Set:
			if (br-1) in Cells_Obj.keys():
				Cells_Obj[br-1].Status=2
		for bn in BurningCells_Set:
			if (bn-1) in Cells_Obj.keys():	
				Cells_Obj[bn-1].Status=2
		
		#verbose = True
		if rank==0 and nooutput == False:
			print "\n"+"----------------------------- Results -----------------------------"
			# General results
			print ""		
			print "--------------------------- Solution without Heuristic --------------------------"
			print "Total Available Cells:    ", len(AvailCells_Set),"- % of the Forest: ", round(len(AvailCells_Set)/float(NCells)*100.0,3),"%"
			#if heuristic!=0:
				#print "Total Harvested Cells:", len(HarvestCells_Set), ", % of the Forest: ", round(len(HarvestCells_Set)/float(NCells)*100.0,2),"%"
			print "Total Burnt Cells:        ", len(BurntCells_Set),"- % of the Forest: ", round(len(BurntCells_Set)/float(NCells)*100.0,3),"%"
			print "Total Non-Burnable Cells: ", len(NonBurnableCells_Set),"- % of the Forest: ", round(len(NonBurnableCells_Set)/float(NCells)*100.0,3),"%"
			
			
			# Statistics: Cells' status, Fire periods, start, end.
			if SaveMem != True:
				print "\n"+"Cells status"
				for i in range(0,NCells):
					if i in Cells_Obj.keys():
						if Cells_Obj[i].get_Status() == "Burnt":
							print "Cell "+str(i+1)+" status: "+ str(Cells_Obj[i].get_Status()) +", Year: "+str(Cells_Obj[i].FireStartsSeason) + ", Week: "+str(round(Cells_Obj[i].Firestarts/(7.0*24.0),0)+1) +", Fire starts (hour): "+ str(Cells_Obj[i].Firestarts)
					#	elif Cells_Obj[i].get_Status() == "Harvested":
					#		print "Cell "+str(i+1)+" status: "+ str(Cells_Obj[i].get_Status()) +", Harvested (Season): "+ str(Cells_Obj[i].Harveststarts)
					#	elif Cells_Obj[i].get_Status() == "Available":
					#		print "Cell "+str(i+1)+" status: "+ str(Cells_Obj[i].get_Status()) +", Harvested (Season): "+ str(Cells_Obj[i].Harveststarts)
					#else:
					#	print "Cell "+str(i+1)+" status: Available"
				
			if SaveMem == True:
				for br in BurntCells_Set:
					print "Cell "+str(br)+" status: Burnt" 
				if verbose == True:
					for av in AvailCells_Set:
						print "Cell "+str(av)+" status: Available" 
			
			if scenarios == True and SaveMem != True:
				print "\n"+"FI parameter recorded to file"
				print "FS parameter recorded to file"
						
			# Visual analysis: Bokeh, maps per fire period, details of each stand and other useful outputs
			Final_Time = time.clock()
			print ""
			print "Final Time:",Final_Time
			print "Total simulation time: ",round(Final_Time-Initial_Time,2)," [s]"
					
		# Plot 
		if rank == 0 and plottrue == True:
			if SaveMem == True:
				Plotter.forest_plotV3_FreeMem(Cells_Obj,emptylist,plotnumber,1,Year,False,Rows,Cols,PlotPath,CoordCells,BurntCells_Set,Sim)
				plotnumber+=1
				
			if SaveMem != True:
				Plotter.forest_plotV3(Cells_Obj,emptylist,plotnumber,1,Year,False,Rows,Cols,PlotPath,Sim)
				plotnumber+=1
		
			combine = args.input_combine
			if combine == True:
				for i in range(1,plotnumber):
					Plotter.Mix(Folder,i,Sim)
					
			#Combine into a GIF using ImageMagick's "convert"-command (called using subprocess.call()):
			'''filenamelist = [0 for i in range(0,plotnumber-1)]
			for i in range(0,plotnumber-1):
				if i < 10:
					filenamelist[i] = Folder+"forest000" + str(i) + ".png"
				if i >= 10 and i < 100:
					filenamelist[i] = Folder+"forest00" + str(i) + ".png"
				if i >= 100 and i<1000 :
					filenamelist[i] = Folder+"forest0" + str(i) + ".png"
			
			
			#MGSIZEX = 569
			#IMGSIZEY = 480
			#convertexepath = "C:\Program Files\ImageMagick-6.9.3-Q16/convert.exe"  # Hardcoded
			#convertcommand = [convertexepath, "-delay", "10", "-size", str(IMGSIZEX) + "X" + str(IMGSIZEY)] + filenamelist + ["FireDynamic.gif"]
			convertcommand = [Folder+"PNG2GIF.bat"]
			call(convertcommand)
			'''
			
			
		#Scenarios and Excel
		if rank == 0:
			#Excel
			exceltrue = args.input_excel
			heuristic = args.input_heur
		
			if exceltrue == True and SaveMem != True:
				
				# Call the function
				Output_Grid.ExcelOutput(Cells_Obj,Sim,Folder,heuristic,TotalSims,TotalYears,NCells,BurntCells_Set,AvailCells_Set)
				
				#print "Charts and plots have been successfully created "
				print "Excel file has been successfully created "
				
			#Scenarios
			# If we are not in the save-memory version, check all the initialized cells and print scenarios.dat
			if SaveMem != True and scenarios==True:
				for cell in BurntCells_Set:
					Cells_Obj[cell-1].FS_definition()
					#print "Cell",cell,":",Cells_Obj[cell-1].FSCell
			
				#Printing forest's data to a txt file
				Output_Grid.ScenarioOutput(TotalYears,Cells_Obj,NCells,BurntCells_Set,Folder,Sim,spotting,verbose)
				
				if nooutput==False:
					print "Scenarios have been successfully created "
				
			if SaveMem == True and scenarios == True and nooutput == False:
				print "\nScenarios cannot be output in Save Memory mode"
			
			if SaveMem == True and exceltrue == True and nooutput == False:
				print "\nStatistics cannot be output in Save Memory mode"
		
		#Cleaning weather
		if fileweather == True:
			del WindDirection
			del WindSpeed
			del Precipitation
			del Temperature
			del RHumidity
		
		# Forest Grid
		if rank == 0 and Outputgrid == True:
			Output_Grid.OutputGrid(Folder,Rows,Cols,BurntCells_Set,Sim,spotting,verbose)
			if nooutput ==False:
				print "Forest Grid has been created"
			
		Sim+=1				
	if nooutput == True:
		Final_Time = time.clock()
		print ""
		print "Final Time:",Final_Time
